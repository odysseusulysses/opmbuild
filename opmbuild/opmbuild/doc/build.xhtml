<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
        <link rel="stylesheet" type="text/css" href="css/common.css" />
        <title>Building OPM Graphs</title>
    </head>
    <body>
        <div id="wrapper">
            <div id="header">Building OPM Graphs</div>
            <ul id="nav">
                <li><a href="index.xhtml">Introduction</a></li>
                <li><a href="install.xhtml">Installation</a></li>
                <li><a href="manual.xhtml">Manual</a></li>
                <li><a href="examples.xhtml">Examples</a></li>
                <li><a href="apidocs/index.html">JavaDoc</a></li>
            </ul>
            <div id="content" class="clearfix">
                <div id="col_1">
                    <h2>User Manual</h2>
                    <ul id="subnav">
                        <li><a href = "manual.xhtml">Table of Contents</a></li>
                        <li><a href = "model.xhtml">Object Model</a></li>
                        <li><a href = "build.xhtml">Building</a></li>
                        <li><a href = "navigate.xhtml">Navigating</a></li>
                        <li><a href = "query.xhtml">Querying</a></li>
                        <li><a href = "poem.xhtml">POEM Format</a></li>
                        <li><a href = "xml.xhtml">XML Serialisation</a></li>
                        <li><a href = "dc.xhtml">Dublin Core Conversion</a></li>
                        <li><a href = "ss.xhtml">SourceSource</a></li>
                    </ul>
                </div>
                <div id="col_2">
                    <h1>Building OPM Graphs</h1>
                    <p>
                        OPM graphs can be built either <i>bottom-up</i>, by creating the components then the graph to contain them,
                        or <i>iteratively</i>, by creating the graph then adding components, or a mixture of the two.
                    </p>

                    <p>
                        We first give a couple of examples of graph building, to give an intuition of
                        how the API works. We then go on to explain how to construct each entity in turn.
                    </p>

                    <h2>Examples</h2>
                    <p>
                        In the following example, a graph is created containing two artifacts, one used by
                        the other generated by a process, with roles named, a timestamp asserted on one edge,
                        and an annotation to an artifact and the graph.
                        <blockquote>
                            import org.opmbuild.*;<br/>
                            import java.util.Date;<br/>
                            ...<br/>
                            <br/>
                            Graph g = new Graph ();<br/>
                            Artifact a1 = new Artifact (), a2 = new Artifact ();<br/>
                            Process p = new Process ();<br/>
                            <br/>
                            g.add (a1);<br/>
                            g.add (a2);<br/>
                            g.add (p);<br/>
                            g.add (new Used (p, "input", a1, new Time (new Date ())));<br/>
                            g.add (new WasGeneratedBy (a2, "output", p));<br/>
                            a1.annotate ("http://my.ontology#owner", "Simon Miles");<br/>
                            g.annotate ("http://my.ontology#author", "Simon Miles");
                        </blockquote>
                    </p>
                    <p>
                        In the next example, we use accounts to describe the refinement of a process p into two sub-processes,
                        p1 and p2.
                        <blockquote>
                            Graph g = new Graph ();<br/>
                            Artifact a1 = new Artifact (), a2 = new Artifact (), a3 = new Artifact ();<br/>
                            Process p = new Process (), p1 = new Process (), p2 = new Process ();<br/>
                            Account coarse = new Account (), fine = new Account ();<br/>
                            <br/>
                            coarse.add (a1);<br/>
                            coarse.add (a3);<br/>
                            coarse.add (p);<br/>
                            coarse.add (new Used (p, a1);<br/>
                            coarse.add (new WasGeneratedBy (a3, p));<br/>
                            fine.add (a1);<br/>
                            fine.add (a2);<br/>
                            fine.add (a3);<br/>
                            fine.add (p1);<br/>
                            fine.add (p2);<br/>
                            fine.add (new Used (p1, a1);<br/>
                            fine.add (new WasGeneratedBy (a2, p1));<br/>
                            fine.add (new Used (p2, a2);<br/>
                            fine.add (new WasGeneratedBy (a3, p2));<br/>
                            g.add (coarse);<br/>
                            g.add (fine);
                        </blockquote>
                        Following either of these examples, the graphs are complete and can
                        be manipulated as we choose, e.g. serialise them, query them, etc.
                    </p>

                    <h2>Accounts</h2>
                    <p>
                        An account is a set of graph elements (artifacts, processes, agents, edges, annotations).
                        Create an account using:
                        <blockquote>Account a = new Account ();</blockquote>
                        The Account object implements the <a href="http://java.sun.com/javase/6/docs/api/java/util/Set.html">java.util.Set API</a>, so has all its associated functionality, e.g. add graph element g to an account using:
                        <blockquote>a.add (g);</blockquote>
                        A graph element can be a member of multiple accounts.
                    </p>

                    <h2>Annotations</h2>
                    <p>
                        Graph elements, and graphs themselves, can be annotated.
                        This means that there is a <a href="http://java.sun.com/javase/6/docs/api/java/util/Set.html">Set</a> of Annotation objects associated with each,
                        where an Annotation has a <a href="http://java.sun.com/javase/6/docs/api/java/lang/String.html">String</a> key and an <a href="http://java.sun.com/javase/6/docs/api/java/lang/Object.html">Object</a> value.
                        Any object which can be annotated implements the Annotated interface.
                        To get the set of annotations associated with an object g:
                        <blockquote>Set&lt;Annotation&gt; notes = g.getAnnotations ();</blockquote>
                        This set can be manipulated directly using the <a href="http://java.sun.com/javase/6/docs/api/java/util/Set.html">Set</a> API to add, search for, or remove annotations.
                        Alternatively, Annotated objects have convenience methods for adding annotations without retrieving the set.
                        The annotate method can take either a key and a value, or an Annotation object.
                        <blockquote>g.annotate (key, value);<br/>
                            g.annotate (note);</blockquote>
                    </p>
                    <p>
                        For convenience, the standard annotation keys from the OPM specification
                        are available as constants in the OPMAnnotations interface, named as in the OPM specification
                        (but capitalised): PNAME, LABEL, TYPE, and VALUE.
                        An example of use could be:
                        <blockquote>p.annotate (OPMAnnotations.LABEL, "my process");</blockquote>
                    </p>

                    <h2>Graphs</h2>
                    <p>
                        A graph is a collection of accounts and is associated with a set of annotations.
                        Create a graph using:
                        <blockquote>Graph g = new Graph ();</blockquote>
                        The Graph object implements <a href="http://java.sun.com/javase/6/docs/api/java/util/Collection.html">java.util.Collection&lt;Account&gt;</a> and implements the Annotated interface.
                        Therefore, to add an account to a graph, you use the standard <a href="http://java.sun.com/javase/6/docs/api/java/util/Collection.html">Collection</a> method.
                        <blockquote>g.add (a);</blockquote>
                        Accounts can be added before, during or after being populated with graph elements, as is most convenient.
                        Each graph has one special account pre-created and included in the collection.
                        This special account is a container for all graph elements which should be serialised as not in any account.
                        It is retrieved by the following method.
                        <blockquote>Account none = g.noAccount ();</blockquote>
                        A convenience method of Graph allows graph elements to be added directly to this account, which is helpful
                        when constructing OPM graphs without accounts.
                        <blockquote>Process p = new Process ();<br/>
                            g.add (p);</blockquote>
                    </p>

                    <h2>Nodes</h2>
                    <p>
                        Artifacts, processes and agents are represented by Artifact, Process and Agent objects, each
                        of which is created using the empty constructor for that class, i.e.
                        <blockquote>Process p = new Process ();<br/>
                            Artifact i = new Artifact ();<br/>
                            Agent g = new Agent ();</blockquote>
                        They can then be annotated or added to accounts as described above.
                        Every node object denotes a separate node in the graph.
                    </p>

                    <h2>Edges</h2>
                    <p>
                        Edges are represented as Used, WasGeneratedBy, WasDerivedFrom and WasTriggeredBy objects.
                        Each has a constructor which takes the connected nodes in the order (effect, cause).
                        <blockquote>Used u = new Used (process1, artifact1);</blockquote>
                    </p>
                    <p>
                        The effect and cause nodes can be retrieved using get methods on the edges.
                        <blockquote>Process p = u.getEffect ();</blockquote>
                        Every edge object denotes a separate edge in the graph.
                    </p>
                    <h3>Roles</h3>
                    <p>
                        Edges which can be annotated with roles are subclasses of RoleAnnotatedEdge.
                        These have alternative constructors taking the role along with effect and cause.
                        The role, if supplied, is given between the effect and cause.
                        <blockquote>Used u = new Used (process1, roleName, artifact1);</blockquote>
                        Such edges also have methods to get and set the role (String).
                        <blockquote>String r = u.getRole ();<br/>
                            u.setRole (r);</blockquote>
                    </p>
                    <h3>Time</h3>
                    <p>
                        Edges which can be annotated with timestamps are subclasses of TimeAnnotatedEdge.
                        A timestamp is an instance of class Time, and is constructed either by specifying two instants ('no earlier than' and 'no later than') or a single instant.
                        These instants are instances of the <a href="http://java.sun.com/javase/6/docs/api/java/util/Date.html">java.util.Date</a> class.
                        <blockquote>Time t = new Time (new Date ());<br/>
                            Time t = new Time (earliest, latest);</blockquote>
                        The edges have alternative constructors taking the timestamp along with effect and cause.
                        The timestamp, if supplied, is given after the cause.
                        <blockquote>Used u = new Used (process1, artifact1, t);</blockquote>
                        Such edges also have methods to get and set the time.
                        <blockquote>Time t = u.getTime ();<br/>
                            u.setTime (t);</blockquote>
                        All RoleAnnotatedEdges are also TimeAnnotatedEdges, so both values can be given on construction.
                        <blockquote>Used u = new Used (process1, roleName, artifact1, t);</blockquote>
                    </p>
                </div>
            </div>
            <div id="footer"><small>
                    Layout by <a href="http://www.free-css.com/" target="_blank">Free CSS.com</a></small></div>
        </div>

    </body>
</html>
